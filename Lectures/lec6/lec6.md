# Topic 6. **Key Exchange.**

## Lecture Plan

1. The Discrete Logarithm Problem. The Baby-Step Giant-Step Method. 

2. Diffie–Hellman Algorithm

3. Shamir’s Three-Pass Protocol.

---

# 1. The Discrete Logarithm Problem. The Baby-Step Giant-Step Method.

Let $p$ be a prime and consider the multiplicative group $\mathbb{Z}_p^{\!*} = \{1,2,\dots,p-1\}$ under multiplication modulo $p$.  

#### Problem statement (modulo $p$)
Given:
- a prime $p$,
- a base $g\in\mathbb{Z}_p^{\!*}$,
- a value $y\in\mathbb{Z}_p^{\!*}$,

find an integer $x$ (with $0\le x<r$) such that

$$
g^{x} \equiv y \pmod{p}.
$$

Such a value $x$ **does not always exist.**

#### Remarks (modulo $p$)

Let $r=\operatorname{ord}_p(g)$ is the order of $g$ modulo $p$ (often $r=p-1$), i.e. minimal $r$ such that $g^{r}\equiv 1\pmod{p}$.
Therefore, exponents are considered modulo $r$ (commonly $r=p-1$ when $g$ is a primitive root).  

Fermat's little theorem implies $a^{p-1}\equiv 1\pmod{p}$ for every $a\in\mathbb{Z}_p^{\!*}$, so the exponent space is naturally cyclic modulo $p-1$ when $g$ is primitive.

#### Cryptographic relevance (modulo $p$)
The presumed **intractability** of solving $g^{x}\equiv y\pmod{p}$ for $x$ (when $p$ is large and chosen appropriately) underlies the security of schemes such as: Diffie–Hellman key exchange modulo $p$, ElGamal encryption modulo $p$, DSA-like signatures working in $\mathbb{Z}_p^*$.

Choosing $p$ and $g$ so that the subgroup order $r$ has a large prime factor is important to avoid efficient attacks that exploit small subgroup structure.

### The Baby-Step Giant-Step

**Goal.** Given a prime $p$, a base $g\in\mathbb{Z}_p^{\!*}$ that generates a subgroup of order $r=\operatorname{ord}_p(g)$ (often $r=p-1$), and a value $y\in\mathbb{Z}_p^*$, find $x$ such that

$$
g^{x}\equiv y \pmod{p}.
$$

If $y$ lies in the subgroup generated by $g$, then

$$
y^{r}\equiv 1 \pmod{p}.
$$

If $y^{r}\not\equiv 1\pmod{p}$, there is no solution $x$ in that subgroup.

#### Algorithm
1. Set

$$
m=\left\lceil\sqrt{r}\right\rceil.
$$

2. **Baby steps.** For each $j=0,1,\dots,m-1$ compute and store

$$
b_j \equiv g^{j} \pmod{p}
$$

as a map $b_j \mapsto j$ (hash table keyed by value modulo $p$).

3. Compute the giant-step multiplier

$$
c \equiv g^{-m} \pmod{p}\qquad\text{(equivalently }c\equiv (g^{m})^{-1}\pmod{p}\text{)}.
$$

   If you do not know $r$, compute the inverse via Fermat:

$$
(g^{m})^{-1}\equiv (g^{m})^{\,p-2}\pmod{p}.
$$

4. **Giant steps.** Initialize $\gamma = y$. For $i=0,1,\dots,m-1$ do:
   - If $\gamma$ equals some stored $b_j$ (i.e. $\gamma \equiv b_j\pmod{p}$), then a solution is

$$
x \equiv i\cdot m + j \pmod{r},
$$

and the algorithm terminates.

- Otherwise update

$$
\gamma \coloneqq \gamma\cdot c \pmod{p}
$$

and continue to the next $i$.
5. If no match after $m$ iterations, then there is no solution with $0\le x<r$.


#### Example of Solving the Discrete Logarithm with Baby-Step Giant-Step

Below is an example of solving the discrete logarithm problem in a group of small order.  
In practice, cryptosystems use groups of large order to increase **cryptographic strength**.

We want to solve:

$$
5^x \equiv 3 \pmod{23}.
$$


##### Step 1. Choose $m$
We take

$$
m = 5 \quad \leftarrow \left(\sqrt{16}+1\right).
$$

Then $i$ will range from $1$ to $5$.

##### Step 2. Construct the "giant steps" table
We compute

$$
5^{im} \equiv 20^i \pmod{23}.
$$

| $i$ | $5^{im} \equiv 20^i \pmod{23}$ |
|-----|-------------------------------|
| 1   | 20 |
| 2   | 9  |
| 3   | 19 |
| 4   | 12 |
| 5   | 10 |


##### Step 3. Construct the "baby steps" table
Now compute

$$
3 \cdot 5^j \pmod{23}, \quad j=1,2,3,4.
$$

| $j$ | $3 \cdot 5^j \pmod{23}$ |
|-----|-------------------------|
| 1   | 15 |
| 2   | 6  |
| 3   | 7  |
| 4   | 12 |


##### Step 4. Match values
We see that for $j=4$ the baby-step value is $12$, which also appears in the giant-step table (at $i=4$).

Thus we can compute:

$$
x = m\cdot i - j = 5\cdot 4 - 4 = 16.
$$

##### Final 

$$
5^{16} \equiv 3 \pmod{23}.
$$


---

# 2. Diffie–Hellman Algorithm

Diffie–Hellman (DH) is an abstract key-exchange method that lets two parties who only share a public description of a group agree on a shared secret over an insecure channel.

![1](https://upload.wikimedia.org/wikipedia/commons/4/46/Diffie-Hellman_Key_Exchange.svg)

Whitfield Diffie and Martin Hellman published (1976) the concept of public-key *key agreement* (their famous paper introduced the idea and a concrete scheme now called Diffie–Hellman).  

Independently related mathematical ideas (e.g., work by ElGamal, and earlier number-theory research) preceded and followed that paper; practical adoption came later as protocols incorporated DH for session key agreement.  

Since then DH (and variants) became standard building blocks in TLS, SSH, IKE/IPsec and many other secure-channel protocols (typically combined with authentication mechanisms).

e fix a large prime $p$ and a base (generator) $g$ that generates a large cyclic subgroup of the multiplicative group $(\mathbb{Z}/p\mathbb{Z})^\times$. All arithmetic below is modulo $p$.

- Public parameters: a prime $p$ and a generator $g$ (both public).  
- Each party chooses a private integer uniformly at random from $\{1,\dots,p-2\}$.

Let Alice choose private exponent $a$ and Bob choose private exponent $b$.

1. Alice computes the public value  
   $A \equiv g^a \pmod p$,  
   and sends $A$ to Bob.
2. Bob computes the public value  
   $B \equiv g^b \pmod p$,  
   and sends $B$ to Alice.
3. Alice computes the shared value  
   $s_A \equiv B^a \equiv (g^b)^a \equiv g^{ab} \pmod p$.
4. Bob computes the shared value  
   $s_B \equiv A^b \equiv (g^a)^b \equiv g^{ab} \pmod p$.

Thus both obtain the same shared secret  
$$K \equiv g^{ab} \pmod p.$$

![1](https://upload.wikimedia.org/wikipedia/commons/a/a3/Diffie-Hellman-Schl%C3%BCsselaustausch.png)

**Key derivation:** In practice the raw integer $s$ is not used directly; instead a key-derivation function (KDF) or hash (e.g. $K = \mathrm{KDF}(\text{encode}(s)\,||\,\text{context})$) produces symmetric keys.

#### Small numeric example (illustrative — *not* secure)
Take $p=23$, $g=5$.  
- Alice picks $a=6$. Then $A = 5^6 \bmod 23 = 8$.  
- Bob picks $b=15$. Then $B = 5^{15} \bmod 23 = 19$.  
- Alice computes $s = B^a \bmod 23 = 19^6 \bmod 23 = 2$.  
- Bob computes $s = A^b \bmod 23 = 8^{15} \bmod 23 = 2$.  
Both obtain the same shared secret $s=2$.  
(Example chosen only to show mechanics; real systems use primes hundreds or thousands of bits long.)

#### Security — why it "works" and why is it hard to break

The security of classical (mod-prime) DH depends on the hardness of the *discrete logarithm problem* (DLP) in the chosen subgroup: given $g$ and $A = g^a \pmod p$, it should be computationally infeasible to recover $a$.  


**Baby-step Giant-step** and **Pollard's rho** solve DLP in time about $O(\sqrt{q})$ arithmetic operations where $q$ is the subgroup order.

**Pohlig–Hellman** reduces DLP to DLPs in prime-power factors of the group order: if $p-1$ has small prime factors, DLP becomes easier.

**Design consequence:** choose parameters so that the subgroup order $q$ is a large prime (or at least has a large prime factor). A common pattern is to use a *safe prime* $p=2q+1$ with $q$ prime; then the subgroup of order $q$ avoids small-factor vulnerabilities.

Attacks and caveats:

- **Pohlig–Hellman.** If $p-1$ factors into small primes, attacker reduces DLP to smaller problems. That motivates choosing $p$ with a large prime factor $q$.  
- **Small-subgroup confinement:** an attacker can force shared secret into a small subgroup; countermeasures are subgroup checks and cofactor handling.  
- **Replay and MitM:** without authentication, DH provides no identity binding — easily exploited by active attackers.  
- **Quantum threat:** a sufficiently large quantum computer running Shor's algorithm would break DLP in polynomial time. This motivates post-quantum alternatives; nevertheless, classical DH remains widely used today in combination with authentication.

#### Parameter choices and implementation notes 

**Generator $g$** should be chosen so that it generates a subgroup of large prime order $q$ dividing $p-1$. For safe primes one often pick $g$ with order $q$. **Avoid small-subgroup attacks:** if an implementation accepts any $B$ and blindly computes $B^a$, an attacker can send a value in a small subgroup and learn information about the private exponent. 


#### How DH appears in real protocols (lecture bullets)

**TLS (HTTPS)** uses (finite-field) DH variants historically (e.g., DHE with modular primes); more modern deployments favor ephemeral elliptic-curve DH (ECDHE). In all cases, DH is combined with authentication (server certificate/signature).  

**SSH** supports DH groups (traditional MODP groups and group-exchange) for key agreement and also uses host keys to authenticate the server.  

**IKE / IPsec** uses DH groups for establishing IPsec SAs; groups are standardized (MODP groups with well-known primes).  

**Other systems.** Many secure-messaging and VPN protocols historically used modular DH or its elliptic-curve variants as the KEM/KA primitive.



**In real implementations never use raw DH outputs as keys**; always apply a modern KDF, validate peer public values, and combine DH with proper authentication. For exercises, using a small prime (like the $p=23$ example) is fine to illustrate exponentiation; for real security always use standardized large primes and follow up-to-date best practices.

---

# 3. Shamir’s Three-Pass Protocol.

Shamir’s Three-Pass Protocol (also called the no-key protocol) lets two parties transfer a secret message across an insecure channel without prior key exchange and without revealing the message to eavesdroppers, by using a *commutative* encryption operation. Its pedagogical value is showing how commutativity can replace shared keys; in practice it is rarely used by itself because it lacks built-in authentication and has practical pitfalls.

Adi Shamir described at 1980s the three-pass idea as an elegant demonstration that confidentiality can be achieved without prior shared keys if encryption is commutative.  

The protocol remained mainly of theoretical and teaching interest; real-world secure channels favor authenticated key-exchange (DH/ECDH + signatures) because of stronger security properties and better resistance to active attacks.


#### Mathematical setting 

We work modulo a prime $p$ and use exponentiation as the commutative operation. Choose $p$ large and let all messages and values lie in the multiplicative group $\{1,\dots,p-1\}$. Each party selects a secret exponent that is invertible modulo $p-1$ (i.e. has multiplicative inverse modulo $p-1$).

Public parameter: a prime $p$ (public).  
Message: $m$ with $1 \le m \le p-1$ (must be in the multiplicative group).  
Alice chooses secret exponent $a$ with $\gcd(a,p-1)=1$ and computes its inverse $a^{-1} \pmod{p-1}$.  
Bob chooses secret exponent $b$ with $\gcd(b,p-1)=1$ and computes its inverse $b^{-1} \pmod{p-1}$.

Protocol steps:

1. Alice computes $x_1 \equiv m^a \pmod p$ and sends $x_1$ to Bob.  
2. Bob computes $x_2 \equiv x_1^b \equiv m^{ab} \pmod p$ and sends $x_2$ to Alice.  
3. Alice computes $x_3 \equiv x_2^{a^{-1}} \equiv m^{ab a^{-1}} \equiv m^b \pmod p$ and sends $x_3$ to Bob.  
4. Bob computes $m \equiv x_3^{b^{-1}} \equiv m^{b b^{-1}} \equiv m \pmod p$.

Because exponentiation commutes, the repeated exponentiation and removal of one exponent returns the original message at the end.

#### Small numeric example 
Choose $p=23$ and message $m=9$.  
- Alice picks $a=5$ with inverse $a^{-1}=9$ modulo $22$ (since $5\cdot 9 \equiv 1 \pmod{22}$).  
- Bob picks $b=7$ with inverse $b^{-1}=19$ modulo $22$ (since $7\cdot 19 \equiv 1 \pmod{22}$).

Compute:

- $x_1 \equiv 9^5 \bmod 23 = 8$.  
- $x_2 \equiv 8^7 \bmod 23 = 12$.  
- $x_3 \equiv 12^9 \bmod 23 = 4$.  
- Bob recovers $m \equiv 4^{19} \bmod 23 = 9$.

All arithmetic above demonstrates the mechanics; real use requires very large $p$ and careful encoding/padding of $m$.

#### Parameter choices and implementation notes

**Prime $p$ and message encoding.** Choose a safe prime $p$ or ensure message $m$ is mapped to an element of a large prime-order subgroup to avoid small-subgroup attacks. Do not allow $m$ to be $0$ or an element with small order. Use proper padding/encoding (e.g., map arbitrary plaintext to subgroup elements securely).  

**Invertible exponents** require $\gcd(a,p-1)=\gcd(b,p-1)=1$. Compute $a^{-1},b^{-1}$ modulo $p-1$ using the extended Euclidean algorithm.  

**Validation.** Recipients should validate received values (e.g., check they lie in $[1,p-1]$ and not in small subgroups) to avoid leaking information about secret exponents.  

**Combine with authentication.** The three-pass primitive must be combined with authentication (signatures or keyed MACs) if used in a real protocol to prevent active substitution attacks.

#### Security — basis and limitations

For a **passive** eavesdropper who only sees $m^a$, $m^{ab}$, and $m^b$, learning $m$ typically requires solving discrete logarithm instances or otherwise breaking the commutative exponentiation (so the difficulty is tied to the discrete logarithm problem in the chosen group).  However, the protocol gives **no authentication**: an active man-in-the-middle (MitM) can intercept and substitute values to learn or alter messages. Authentication mechanisms (signatures, MACs, or prior public keys) are required to prevent active attacks.  

The protocol also relies on proper choice of exponents: $a$ and $b$ must be invertible modulo $p-1$; otherwise an exponent removal step fails.


#### Attacks and caveats

Without authentication a MitM can perform independent three-pass exchanges with each party and obtain the plaintext or modify it. This is the main practical reason the protocol is seldom used alone.  

If $m$ or exchanged values sit in a small subgroup an attacker may deduce information about exponents; enforce subgroup checks.  

Protocol messages are simple exponentiations; include session identifiers or nonces if protocol context matters.  

Like other exponentiation-based schemes, a large quantum computer running Shor’s algorithm would break the discrete log problem and defeat security.

#### Where this idea shows up in practice

The three-pass protocol is primarily a teaching example demonstrating commutative encryption. Real systems more commonly use **authenticated key agreement** (e.g., DH/ECDH with signatures) rather than pure no-key three-pass transfers.  

Variants exist using other commutative operations (e.g., scalar multiplication on elliptic curves behaves similarly: $(k_1(k_2P))=(k_2(k_1P))$), but the same practical concerns (authentication, subgroup checks, encoding) apply.

#### Note

The three-pass protocol is an elegant demonstration of commutative encryption and useful for exercises. For any real application ensure large primes, canonical encoding of $m$ into the group, subgroup and value validation, and — crucially — authentication to prevent active attacks. 

